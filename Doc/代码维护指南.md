# SVN监控系统 - 代码维护文档

## 1. 维护流程和策略

### 1.1 日常维护流程

#### 监控系统健康检查
```python
# 健康检查脚本示例
#!/usr/bin/env python3
"""
SVN监控系统健康检查脚本

检查项目：
1. 监控进程状态
2. 日志文件大小和内容
3. 配置文件有效性
4. 网络连接状态
5. 磁盘空间使用
"""

import psutil
import logging
from datetime import datetime
from pathlib import Path

class HealthChecker:
    """系统健康检查器"""
    
    def __init__(self, config_path: str):
        self.config_path = config_path
        self.logger = logging.getLogger('health_check')
    
    def check_process_status(self) -> bool:
        """检查监控进程状态"""
        try:
            # 查找SVN监控进程
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                if 'svn_monitor' in ' '.join(proc.info['cmdline'] or []):
                    if proc.status() == 'running':
                        self.logger.info("监控进程运行正常 (PID: %s)", proc.pid)
                        return True
            
            self.logger.error("未找到运行的监控进程")
            return False
            
        except Exception as e:
            self.logger.error("检查进程状态失败: %s", e)
            return False
    
    def check_log_files(self) -> bool:
        """检查日志文件状态"""
        log_path = Path('/var/log/svn_monitor')
        
        if not log_path.exists():
            self.logger.error("日志目录不存在: %s", log_path)
            return False
        
        # 检查日志文件大小
        for log_file in log_path.glob('*.log'):
            size_mb = log_file.stat().st_size / (1024 * 1024)
            if size_mb > 100:  # 超过100MB
                self.logger.warning("日志文件过大: %s (%.1fMB)", log_file.name, size_mb)
        
        # 检查错误日志
        error_log = log_path / 'error.log'
        if error_log.exists() and error_log.stat().st_size > 0:
            self.logger.warning("错误日志文件非空，可能存在问题")
        
        return True
    
    def run_health_check(self) -> Dict[str, bool]:
        """执行完整健康检查"""
        checks = {
            'process_status': self.check_process_status(),
            'log_files': self.check_log_files(),
            'config_valid': self.check_configuration(),
            'network_connectivity': self.check_network(),
            'disk_space': self.check_disk_space()
        }
        
        # 生成检查报告
        report = {
            'timestamp': datetime.now().isoformat(),
            'checks': checks,
            'overall_status': all(checks.values())
        }
        
        self.logger.info("健康检查完成: %s", report)
        return report
```

#### 定期维护任务
```markdown
# 定期维护任务清单

## 每日任务
- [ ] 检查监控进程状态
- [ ] 查看错误日志
- [ ] 验证配置文件
- [ ] 检查磁盘空间使用

## 每周任务
- [ ] 清理过期日志文件
- [ ] 备份配置文件
- [ ] 更新依赖包版本检查
- [ ] 性能指标分析

## 每月任务
- [ ] 系统安全更新
- [ ] 代码质量检查
- [ ] 测试覆盖率分析
- [ ] 文档更新检查
```

### 1.2 问题排查流程

#### 常见问题排查指南
```python
# 问题排查工具类
class Troubleshooter:
    """问题排查工具"""
    
    def diagnose_common_issues(self) -> List[Dict]:
        """诊断常见问题"""
        issues = []
        
        # 检查配置问题
        config_issues = self._check_config_issues()
        issues.extend(config_issues)
        
        # 检查网络问题
        network_issues = self._check_network_issues()
        issues.extend(network_issues)
        
        # 检查权限问题
        permission_issues = self._check_permission_issues()
        issues.extend(permission_issues)
        
        return issues
    
    def _check_config_issues(self) -> List[Dict]:
        """检查配置相关问题"""
        issues = []
        
        # 检查配置文件存在性
        if not os.path.exists(self.config_path):
            issues.append({
                'type': 'config',
                'severity': 'high',
                'description': '配置文件不存在',
                'solution': '请检查配置文件路径或重新生成配置'
            })
        
        # 检查配置格式
        try:
            config = self._load_config()
            self._validate_config(config)
        except Exception as e:
            issues.append({
                'type': 'config',
                'severity': 'high',
                'description': f'配置文件格式错误: {e}',
                'solution': '请检查配置文件格式和内容'
            })
        
        return issues
    
    def generate_troubleshooting_report(self) -> str:
        """生成问题排查报告"""
        issues = self.diagnose_common_issues()
        
        report = "# SVN监控系统问题排查报告\n\n"
        report += f"生成时间: {datetime.now().isoformat()}\n\n"
        
        if not issues:
            report += "✅ 未发现明显问题\n"
        else:
            report += "## 发现的问题\n\n"
            for issue in issues:
                report += f"### {issue['type'].upper()} 问题\n"
                report += f"**严重程度**: {issue['severity']}\n"
                report += f"**描述**: {issue['description']}\n"
                report += f"**解决方案**: {issue['solution']}\n\n"
        
        return report
```

## 2. 版本管理和发布

### 2.1 版本控制策略

#### 分支管理规范
```markdown
# 分支管理策略

## 主要分支
- `main`：主分支，保持稳定可发布状态
- `develop`：开发分支，集成功能开发

## 支持分支
- `feature/*`：功能开发分支
- `bugfix/*`：Bug修复分支
- `hotfix/*`：紧急修复分支
- `release/*`：发布准备分支

## 分支命名规范
- 功能分支：feature/功能描述-日期（feature/user-auth-20240115）
- Bug修复分支：bugfix/问题描述-日期（bugfix/email-timeout-20240115）
- 紧急修复分支：hotfix/问题描述-日期（hotfix/critical-bug-20240115）
```

#### 版本发布流程
```python
# 版本发布脚本
#!/usr/bin/env python3
"""
版本发布自动化脚本

功能：
1. 版本号验证和更新
2. 代码质量检查
3. 测试执行
4. 文档生成
5. 发布包构建
"""

import semver
import subprocess
from pathlib import Path

class ReleaseManager:
    """版本发布管理器"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.version_file = self.project_root / 'VERSION'
    
    def validate_release_readiness(self) -> bool:
        """验证发布准备状态"""
        checks = [
            self._check_version_consistency(),
            self._run_code_quality_checks(),
            self._run_test_suite(),
            self._check_documentation(),
            self._verify_dependencies()
        ]
        
        return all(checks)
    
    def create_release_branch(self, version: str) -> bool:
        """创建发布分支"""
        branch_name = f"release/v{version}"
        
        try:
            # 切换到develop分支
            subprocess.run(['git', 'checkout', 'develop'], check=True)
            
            # 创建发布分支
            subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
            
            # 更新版本号
            self._update_version_file(version)
            
            # 提交版本更新
            subprocess.run(['git', 'add', 'VERSION'], check=True)
            subprocess.run(['git', 'commit', '-m', f'Bump version to {version}'], check=True)
            
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"创建发布分支失败: {e}")
            return False
    
    def build_release_package(self, version: str) -> bool:
        """构建发布包"""
        try:
            # 清理构建目录
            subprocess.run(['rm', '-rf', 'dist/'], check=True)
            
            # 构建包
            subprocess.run(['python', 'setup.py', 'sdist', 'bdist_wheel'], check=True)
            
            # 验证包
            subprocess.run(['twine', 'check', 'dist/*'], check=True)
            
            print(f"✅ 版本 {version} 发布包构建成功")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"构建发布包失败: {e}")
            return False
```

### 2.2 变更管理

#### 变更记录模板
```markdown
# 变更记录模板

## 变更概述
- **变更类型**：[功能新增/缺陷修复/性能优化/安全修复]
- **影响范围**：[模块名称或功能描述]
- **优先级**：[高/中/低]

## 变更详情
### 变更原因
[描述为什么要进行这个变更]

### 变更内容
[详细描述变更的具体内容]

### 测试验证
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 性能测试通过
- [ ] 安全测试通过

## 风险评估
### 可能的风险
[列出变更可能带来的风险]

### 缓解措施
[描述如何缓解这些风险]

## 回滚计划
[描述如果变更失败如何回滚]
```

## 3. 性能监控和优化

### 3.1 性能指标监控

#### 关键性能指标
```python
# 性能监控类
class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self):
        self.metrics = {}
        self.start_time = time.time()
    
    def record_metric(self, name: str, value: float, tags: Dict = None):
        """记录性能指标"""
        if name not in self.metrics:
            self.metrics[name] = []
        
        metric_data = {
            'value': value,
            'timestamp': time.time(),
            'tags': tags or {}
        }
        self.metrics[name].append(metric_data)
    
    def get_performance_report(self) -> Dict:
        """生成性能报告"""
        report = {
            'uptime': time.time() - self.start_time,
            'metrics': {}
        }
        
        for metric_name, data_points in self.metrics.items():
            if data_points:
                values = [dp['value'] for dp in data_points]
                report['metrics'][metric_name] = {
                    'count': len(values),
                    'min': min(values),
                    'max': max(values),
                    'avg': sum(values) / len(values),
                    'latest': values[-1]
                }
        
        return report

# 关键性能指标定义
KEY_METRICS = {
    'monitor.check_duration': '单次检查耗时',
    'monitor.repositories_count': '监控仓库数量',
    'mail.send_duration': '邮件发送耗时',
    'memory.usage': '内存使用量',
    'network.latency': '网络延迟'
}
```

#### 性能优化策略
```python
# 性能优化工具
class PerformanceOptimizer:
    """性能优化器"""
    
    def analyze_bottlenecks(self, metrics: Dict) -> List[Dict]:
        """分析性能瓶颈"""
        bottlenecks = []
        
        # 检查监控检查耗时
        if metrics.get('monitor.check_duration', {}).get('avg', 0) > 10:
            bottlenecks.append({
                'type': 'monitoring',
                'description': '监控检查耗时过长',
                'suggestion': '考虑优化SVN命令执行或增加检查间隔'
            })
        
        # 检查邮件发送耗时
        if metrics.get('mail.send_duration', {}).get('avg', 0) > 5:
            bottlenecks.append({
                'type': 'mail',
                'description': '邮件发送耗时过长',
                'suggestion': '考虑使用邮件队列或异步发送'
            })
        
        # 检查内存使用
        memory_usage = metrics.get('memory.usage', {}).get('latest', 0)
        if memory_usage > 500:  # 500MB
            bottlenecks.append({
                'type': 'memory',
                'description': '内存使用量过高',
                'suggestion': '检查内存泄漏或优化数据缓存策略'
            })
        
        return bottlenecks
    
    def generate_optimization_plan(self, bottlenecks: List[Dict]) -> str:
        """生成优化计划"""
        plan = "# 性能优化计划\n\n"
        
        if not bottlenecks:
            plan += "✅ 当前未发现明显的性能瓶颈\n"
        else:
            plan += "## 发现的性能瓶颈\n\n"
            
            for i, bottleneck in enumerate(bottlenecks, 1):
                plan += f"### {i}. {bottleneck['type'].upper()} 瓶颈\n"
                plan += f"**问题描述**: {bottleneck['description']}\n"
                plan += f"**优化建议**: {bottleneck['suggestion']}\n\n"
        
        return plan
```

## 4. 安全维护

### 4.1 安全漏洞管理

#### 漏洞扫描和修复
```python
# 安全扫描工具
class SecurityScanner:
    """安全扫描器"""
    
    def scan_dependencies(self) -> List[Dict]:
        """扫描依赖包安全漏洞"""
        vulnerabilities = []
        
        try:
            # 使用安全扫描工具（如safety）
            result = subprocess.run(
                ['safety', 'check', '--json'],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                # 解析安全扫描结果
                vuln_data = json.loads(result.stdout)
                for vuln in vuln_data.get('vulnerabilities', []):
                    vulnerabilities.append({
                        'package': vuln['package_name'],
                        'version': vuln['vulnerable_version'],
                        'severity': vuln['severity'],
                        'description': vuln['advisory'],
                        'solution': f"升级到版本 {vuln['fixed_version']}"
                    })
            
        except Exception as e:
            print(f"安全扫描失败: {e}")
        
        return vulnerabilities
    
    def check_code_security(self) -> List[Dict]:
        """检查代码安全漏洞"""
        issues = []
        
        # 检查常见安全漏洞模式
        security_patterns = [
            (r'os\.system\(', '命令注入风险'),
            (r'eval\(', '代码执行风险'),
            (r'pickle\.loads\(', '反序列化风险'),
            (r'password.*=.*["\']', '硬编码密码风险')
        ]
        
        for pattern, description in security_patterns:
            matches = self._search_code_pattern(pattern)
            for match in matches:
                issues.append({
                    'file': match['file'],
                    'line': match['line'],
                    'pattern': pattern,
                    'description': description,
                    'severity': 'high'
                })
        
        return issues
```

### 4.2 安全更新策略

#### 安全更新检查清单
```markdown
# 安全更新检查清单

## 依赖包安全更新
- [ ] 定期检查依赖包安全公告
- [ ] 及时更新存在安全漏洞的包
- [ ] 验证更新后功能正常
- [ ] 更新依赖包版本记录

## 系统安全配置
- [ ] 检查文件权限设置
- [ ] 验证网络访问控制
- [ ] 更新SSL/TLS证书
- [ ] 审查日志安全设置

## 代码安全审查
- [ ] 检查输入验证逻辑
- [ ] 验证错误处理安全
- [ ] 审查认证授权机制
- [ ] 检查数据加密使用
```

## 5. 备份和恢复

### 5.1 数据备份策略

#### 备份脚本示例
```python
# 数据备份脚本
#!/usr/bin/env python3
"""
SVN监控系统数据备份脚本

备份内容：
1. 配置文件
2. 监控状态数据
3. 日志文件
4. 数据库文件（如有）
"""

import shutil
from datetime import datetime
from pathlib import Path

class BackupManager:
    """备份管理器"""
    
    def __init__(self, backup_root: str):
        self.backup_root = Path(backup_root)
        self.backup_root.mkdir(exist_ok=True)
    
    def create_backup(self) -> str:
        """创建完整备份"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = self.backup_root / f"backup_{timestamp}"
        backup_dir.mkdir()
        
        # 备份配置文件
        self._backup_config_files(backup_dir)
        
        # 备份状态数据
        self._backup_state_data(backup_dir)
        
        # 备份日志文件
        self._backup_log_files(backup_dir)
        
        # 创建备份元数据
        self._create_backup_metadata(backup_dir, timestamp)
        
        return str(backup_dir)
    
    def _backup_config_files(self, backup_dir: Path):
        """备份配置文件"""
        config_files = [
            'svn_monitor_config.xlsx',
            'recipients.xlsx'
        ]
        
        config_backup_dir = backup_dir / 'config'
        config_backup_dir.mkdir()
        
        for config_file in config_files:
            source = Path(config_file)
            if source.exists():
                shutil.copy2(source, config_backup_dir / source.name)
    
    def list_backups(self) -> List[Dict]:
        """列出所有备份"""
        backups = []
        
        for backup_dir in self.backup_root.glob('backup_*'):
            if backup_dir.is_dir():
                metadata_file = backup_dir / 'metadata.json'
                if metadata_file.exists():
                    with open(metadata_file) as f:
                        metadata = json.load(f)
                        backups.append({
                            'path': str(backup_dir),
                            'timestamp': metadata['timestamp'],
                            'size': self._get_directory_size(backup_dir)
                        })
        
        return sorted(backups, key=lambda x: x['timestamp'], reverse=True)
```

#### 恢复流程
```markdown
# 数据恢复流程

## 恢复准备
1. 停止监控服务
2. 确认备份文件完整性
3. 准备恢复环境

## 恢复步骤
1. 解压备份文件到临时目录
2. 验证备份数据完整性
3. 恢复配置文件
4. 恢复状态数据
5. 恢复日志文件（可选）

## 恢复验证
1. 启动监控服务
2. 验证功能正常
3. 检查数据一致性
4. 更新恢复记录

## 紧急恢复
对于紧急情况，提供快速恢复脚本：
```bash
python restore_backup.py --backup=最新备份路径 --quick
```
```

---
*本文档提供了SVN监控系统的完整维护指南，包括日常维护、问题排查、版本管理、性能优化、安全维护和备份恢复等方面的详细说明。*