# SVN监控系统 - 代码规范文档

## 1. 代码风格规范

### 1.1 命名规范

#### 变量命名
- **小写字母 + 下划线**：使用蛇形命名法（snake_case）
- **描述性命名**：变量名应清晰表达其用途
- **避免缩写**：除非是广泛接受的缩写（如config、temp）

```python
# 好的命名
repository_path = "/svn/repo"
last_checked_time = datetime.now()
error_count = 0

# 不好的命名
rp = "/svn/repo"  # 缩写不明确
lct = datetime.now()  # 缩写难以理解
cnt = 0  # 意义不明确
```

#### 函数命名
- **动词开头**：函数名应以动词开头，描述其行为
- **清晰表达功能**：函数名应准确描述其功能

```python
# 好的函数命名
def check_repository_status():
def send_email_notification():
def parse_config_file():

# 不好的函数命名
def repo_check():  # 不明确
def email():  # 过于简单
def config():  # 意义不明确
```

#### 类命名
- **驼峰命名法**：使用大驼峰命名法（PascalCase）
- **名词形式**：类名通常是名词或名词短语

```python
# 好的类命名
class SVNMonitor:
class EmailSender:
class ConfigParser:

# 不好的类命名
class svn_monitor:  # 应使用驼峰命名
class email_sender:  # 应使用驼峰命名
class configparser:  # 应使用驼峰命名
```

#### 常量命名
- **全大写 + 下划线**：常量使用全大写字母
- **模块级常量**：在模块顶部定义

```python
# 常量定义
MAX_RETRY_COUNT = 3
DEFAULT_CHECK_INTERVAL = 30
LOG_FILE_PATH = "/var/log/svn_monitor.log"
```

### 1.2 代码格式规范

#### 缩进和空格
- **4个空格缩进**：使用4个空格进行缩进
- **操作符空格**：操作符前后添加空格
- **逗号后空格**：逗号后添加空格

```python
# 好的格式
if current_revision > last_revision:
    self.handle_new_commit(repo_config, current_revision)

result = a + b * c  # 操作符前后有空格
recipients = ['user1@example.com', 'user2@example.com']  # 逗号后有空格

# 不好的格式
if current_revision>last_revision:  # 操作符缺少空格
    self.handle_new_commit(repo_config,current_revision)  # 逗号缺少空格
```

#### 行长度限制
- **最大79字符**：每行代码不超过79个字符
- **合理换行**：使用括号、反斜杠或自然断点进行换行

```python
# 好的换行方式
email_subject = (
    f"[SVN监控] {repository_name} "
    f"有新提交 (版本{revision_number})"
)

# 函数调用换行
result = send_email_notification(
    recipient_list=recipients,
    subject=email_subject,
    body=email_body,
    attachments=changed_files
)
```

#### 导入规范
- **分组导入**：按标准库、第三方库、本地模块分组
- **每行一个导入**：每个import语句导入一个模块
- **绝对导入**：优先使用绝对导入

```python
# 标准库导入
import os
import sys
import logging
from datetime import datetime
from typing import Dict, List, Optional

# 第三方库导入
import smtplib
from email.mime.text import MIMEText

# 本地模块导入
from modules.monitor import RepositoryMonitor
from utils.config_loader import load_config
```

### 1.3 注释规范

#### 文档字符串（Docstring）
- **使用三重引号**：使用"""三重引号包围
- **包含功能描述**：描述模块、类、函数的功能
- **参数和返回值**：说明参数类型和返回值

```python
def check_repository_status(repo_path: str) -> Dict[str, any]:
    """
    检查SVN仓库状态
    
    参数：
        repo_path: SVN仓库路径
        
    返回值：
        Dict: 包含仓库状态信息的字典
        
    异常：
        SVNConnectionError: SVN连接失败时抛出
    """
    # 实现代码...
```

#### 行内注释
- **解释复杂逻辑**：对复杂算法或业务逻辑进行解释
- **避免明显注释**：不要注释显而易见的代码

```python
# 好的行内注释
# 计算版本号差异，避免重复通知
if current_revision - last_revision > 0:
    # 检测到新提交，准备发送通知
    self.prepare_notification(repo_config, current_revision)

# 不好的行内注释
x = x + 1  # 给x加1（过于明显）
```

## 2. 编程实践规范

### 2.1 错误处理

#### 异常处理原则
- **具体异常捕获**：捕获具体的异常类型
- **避免裸except**：不要使用裸露的except语句
- **记录异常信息**：记录详细的异常信息

```python
# 好的异常处理
try:
    result = subprocess.run(command, timeout=30)
except subprocess.TimeoutExpired:
    logging.error("命令执行超时: %s", command)
    raise CommandTimeoutError("命令执行超时")
except subprocess.CalledProcessError as e:
    logging.error("命令执行失败: %s", e.stderr)
    raise CommandExecutionError(f"命令执行失败: {e.stderr}")

# 不好的异常处理
try:
    result = subprocess.run(command)
except:  # 裸except，会捕获所有异常
    print("出错了")
```

#### 自定义异常
- **继承Exception**：自定义异常类应继承Exception
- **提供有用信息**：异常应包含有用的错误信息

```python
class SVNMonitorError(Exception):
    """SVN监控系统基础异常类"""
    pass

class ConfigError(SVNMonitorError):
    """配置相关异常"""
    def __init__(self, message: str, config_path: str = None):
        super().__init__(message)
        self.config_path = config_path
```

### 2.2 类型提示

#### 基本类型提示
- **函数参数和返回值**：为函数参数和返回值添加类型提示
- **变量类型**：为重要变量添加类型提示

```python
from typing import Dict, List, Optional, Union

def load_config(config_path: str) -> Dict[str, any]:
    """加载配置文件"""
    pass

def get_recipients(repo_name: str) -> List[str]:
    """获取收件人列表"""
    pass

def find_repository(path: str) -> Optional[Dict[str, any]]:
    """查找仓库配置，可能返回None"""
    pass
```

#### 复杂类型提示
- **使用TypedDict**：为字典结构定义明确的类型
- **使用Literal**：为有限的选项值定义类型

```python
from typing import TypedDict, Literal

class RepositoryConfig(TypedDict):
    """仓库配置类型定义"""
    name: str
    path: str
    check_interval: int
    recipients: List[str]

def set_log_level(level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR']) -> None:
    """设置日志级别"""
    pass
```

### 2.3 函数设计

#### 单一职责原则
- **一个函数一个功能**：每个函数只负责一个明确的功能
- **合理函数长度**：函数长度建议不超过50行

```python
# 好的函数设计
def process_repository_update(repo_config: Dict) -> bool:
    """处理仓库更新"""
    # 检查变更
    has_changes = check_for_changes(repo_config)
    
    if has_changes:
        # 准备通知
        notification_data = prepare_notification_data(repo_config)
        # 发送通知
        return send_notification(notification_data)
    
    return False

# 不好的函数设计（功能过多）
def handle_repository():
    """处理仓库的所有操作"""
    # 检查变更、准备数据、发送邮件、更新状态...
    # 函数过长，职责过多
```

#### 参数设计
- **合理参数数量**：参数数量建议不超过5个
- **使用关键字参数**：对于可选参数使用关键字参数

```python
# 好的参数设计
def send_email(recipients: List[str], subject: str, body: str, 
               attachments: List[str] = None, priority: str = 'normal') -> bool:
    """发送邮件"""
    pass

# 调用时使用关键字参数
send_email(
    recipients=['user@example.com'],
    subject="测试邮件",
    body="邮件内容",
    priority='high'
)
```

## 3. 安全规范

### 3.1 输入验证

#### 配置文件验证
- **验证必填字段**：检查配置文件的必填字段
- **验证数据类型**：确保配置值的类型正确
- **验证取值范围**：检查数值型配置的合理范围

```python
def validate_config(config: Dict) -> bool:
    """验证配置文件"""
    # 检查必填字段
    required_fields = ['repositories', 'mail']
    for field in required_fields:
        if field not in config:
            raise ConfigError(f"缺少必填字段: {field}")
    
    # 验证邮件配置
    mail_config = config['mail']
    if not isinstance(mail_config.get('port'), int):
        raise ConfigError("邮件端口必须是整数")
    
    # 验证端口范围
    if not (1 <= mail_config['port'] <= 65535):
        raise ConfigError("邮件端口范围无效")
    
    return True
```

#### 路径安全
- **防止路径遍历**：验证文件路径，防止目录遍历攻击
- **使用绝对路径**：优先使用绝对路径

```python
import os

def safe_join(base_path: str, sub_path: str) -> str:
    """安全的路径拼接"""
    # 规范化路径
    full_path = os.path.normpath(os.path.join(base_path, sub_path))
    
    # 确保路径在基础目录内
    if not full_path.startswith(os.path.abspath(base_path)):
        raise SecurityError("路径遍历攻击检测")
    
    return full_path
```

### 3.2 敏感信息处理

#### 密码和密钥
- **不硬编码密码**：避免在代码中硬编码密码
- **使用环境变量**：敏感信息通过环境变量传递
- **配置文件加密**：敏感配置文件可考虑加密

```python
import os

def get_database_password() -> str:
    """从环境变量获取数据库密码"""
    password = os.environ.get('DB_PASSWORD')
    if not password:
        raise ConfigError("数据库密码未设置")
    return password
```

#### 日志安全
- **不记录敏感信息**：避免在日志中记录密码、密钥等敏感信息
- **脱敏处理**：对敏感信息进行脱敏处理

```python
def safe_log_config(config: Dict) -> Dict:
    """安全的配置日志记录"""
    safe_config = config.copy()
    
    # 脱敏敏感字段
    if 'password' in safe_config:
        safe_config['password'] = '***'
    if 'api_key' in safe_config:
        safe_config['api_key'] = '***'
    
    return safe_config
```

## 4. 性能规范

### 4.1 资源管理

#### 连接池管理
- **使用连接池**：对于频繁的网络操作使用连接池
- **及时释放资源**：确保资源在使用后及时释放

```python
from contextlib import contextmanager

class ConnectionPool:
    """连接池管理"""
    
    @contextmanager
    def get_connection(self):
        """获取连接（上下文管理器）"""
        connection = self._acquire_connection()
        try:
            yield connection
        finally:
            self._release_connection(connection)

# 使用示例
with connection_pool.get_connection() as conn:
    conn.send_command(command)
# 连接自动释放
```

#### 文件操作
- **使用with语句**：文件操作使用with语句确保关闭
- **批量操作**：对于大量文件操作使用批量处理

```python
# 好的文件操作
with open('svn_monitor_config.xlsx', 'rb') as f:
    config_data = pd.read_excel(f)

# 批量读取文件
def batch_process_files(file_list: List[str]) -> List[str]:
    """批量处理文件"""
    results = []
    for file_path in file_list:
        with open(file_path, 'r') as f:
            results.append(f.read())
    return results
```

### 4.2 内存管理

#### 避免内存泄漏
- **及时释放大对象**：对于大对象及时释放引用
- **使用生成器**：对于大数据集使用生成器

```python
# 使用生成器处理大数据
def read_large_file(file_path: str):
    """逐行读取大文件"""
    with open(file_path, 'r') as f:
        for line in f:
            yield line.strip()

# 使用示例
for line in read_large_file('large_log.txt'):
    process_line(line)
```

#### 缓存策略
- **合理使用缓存**：对于频繁访问的数据使用缓存
- **设置缓存过期**：缓存数据设置合理的过期时间

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_repository_info(repo_path: str) -> Dict:
    """获取仓库信息（带缓存）"""
    # 昂贵的操作，结果会被缓存
    return expensive_operation(repo_path)
```

## 5. 测试规范

### 5.1 单元测试

#### 测试结构
- **测试类命名**：测试类以Test开头
- **测试方法命名**：测试方法以test_开头
- **使用断言**：使用明确的断言语句

```python
import unittest
from unittest.mock import patch

class TestSVNMonitor(unittest.TestCase):
    """SVNMonitor测试类"""
    
    def setUp(self):
        """测试前置设置"""
        self.monitor = SVNMonitor(test_config)
    
    def test_detect_changes_with_new_commit(self):
        """测试检测新提交"""
        with patch('modules.monitor.get_latest_revision') as mock_rev:
            mock_rev.return_value = 100
            
            result = self.monitor.detect_changes()
            
            self.assertTrue(result)
            self.assertEqual(self.monitor.last_revision, 100)
    
    def test_detect_changes_without_new_commit(self):
        """测试没有新提交的情况"""
        with patch('modules.monitor.get_latest_revision') as mock_rev:
            mock_rev.return_value = 50
            
            result = self.monitor.detect_changes()
            
            self.assertFalse(result)
```

#### 测试覆盖
- **边界条件测试**：测试边界条件和异常情况
- **错误路径测试**：测试错误处理路径

```python
def test_invalid_repository_path(self):
    """测试无效仓库路径"""
    with self.assertRaises(SVNConnectionError):
        self.monitor.check_repository("invalid_path")

def test_network_timeout(self):
    """测试网络超时"""
    with patch('modules.monitor.get_latest_revision', 
               side_effect=SVNConnectionError("连接超时")):
        result = self.monitor.detect_changes()
        
        self.assertFalse(result)
        self.assertEqual(self.monitor.error_count, 1)
```

### 5.2 集成测试

#### 测试环境
- **使用测试配置**：集成测试使用专门的测试配置
- **模拟外部依赖**：对于外部服务使用模拟或测试双倍

```python
class TestEmailIntegration(unittest.TestCase):
    """邮件集成测试"""
    
    def setUp(self):
        """设置测试邮件服务器"""
        self.smtp_server = smtpd.DebuggingServer(('localhost', 0))
        self.smtp_thread = threading.Thread(target=self.smtp_server.serve_forever)
        self.smtp_thread.daemon = True
        self.smtp_thread.start()
    
    def test_email_sending(self):
        """测试邮件发送"""
        sender = EmailSender({
            'smtp_server': 'localhost',
            'port': self.smtp_server.port,
            'username': 'test@example.com'
        })
        
        result = sender.send_notification(test_data, ['test@example.com'])
        
        self.assertTrue(result)
        self.assertEqual(len(self.smtp_server.messages), 1)
```

## 6. 文档规范

### 6.1 代码文档

#### README文件
- **项目概述**：简要描述项目功能和用途
- **安装说明**：提供清晰的安装步骤
- **使用示例**：提供基本的使用示例

#### API文档
- **自动生成**：使用Sphinx等工具自动生成API文档
- **示例代码**：为每个API提供使用示例
- **参数说明**：详细说明每个参数的含义和类型

### 6.2 变更日志

#### 版本记录
- **语义化版本**：使用语义化版本号（MAJOR.MINOR.PATCH）
- **变更说明**：记录每个版本的变更内容
- **兼容性说明**：说明版本间的兼容性变化

```markdown
# 变更日志

## [1.2.0] - 2024-01-15
### 新增
- 支持多收件人邮件通知
- 添加配置文件验证功能

### 修复
- 修复版本号检测逻辑错误
- 解决邮件发送超时问题

### 变更
- 更新依赖库版本
- 优化日志输出格式
```

---
*本文档规定了SVN监控系统的代码编写规范，所有开发人员应严格遵守这些规范以确保代码质量和可维护性。*